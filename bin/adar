#!/usr/bin/perl
#
use strict;
use warnings;
use Carp;
use Config::IniFiles;
use Data::Dumper;

=pod

=head2 DB descriptor from DDM

    %dbdesc = {
        ddm => 'dummy.ddm',
        files => {
            'FILE1' => { fdt => 'dummy1.fdt', bin => 'dummy1.bin' },
            'FILE2' => { fdt => 'dummy2.fdt', bin => 'dummy2.bin' },
        },
        fields => {
            1 => { name => AA, 'type' => 'S', comment => '...', },
            2 => { name => AB, 'type' => 'K', comment => '...', },
        },
    };

=cut

my $DEBUG = 1;

sub pnt_open {
    my $filename = shift @_;

    my $fh;
    open $fh, '<', $filename or croak "Couldn't open file $filename: $!\n";
    binmode $fh;

    return $fh;
}

sub fdt_open {
    my $filename = shift @_;

    my $fh;
    open $fh, '<', $filename or croak "Couldn't open file $filename: $!\n";
    binmode $fh;

    return $fh;
}

sub fdt_close {
    my $fh = shift @_;

    close $fh or croak "Couldn't close file: $!\n";
}

sub read_zstring {
    my $fh      = shift @_;
    my $content = 0;

    my $text = '';
  ZSTRING:
    while ( read( $fh, $content, 1 ) ) {
        my $c = unpack 'C', $content;
        last ZSTRING if !$c;
        $text .= $content,;
    }

    return $text;
}

sub read_lstring {
    my $fh = shift @_;

    my $l    = read_u16le($fh);
    my $text = read_zstring($fh);

    croak "input not an lstring : length($text) != $l"
      if $l != 1 + length($text);
    return $text;
}

sub read_string {
    my $fh = shift @_;

    my $text = '';
    while ( read $fh, my $packed_length, 2 ) {
        my $length = unpack 'v', $packed_length;

        read $fh, $text, $length;

        print STDERR $length, "\t", $text, "\n"
          if $DEBUG;
    }
    return $text;
}

sub read_char {
    my $fh = shift @_;
    read $fh, my $content, 1;
    return $content;
}

sub read_u8 {
    my $fh = shift @_;
    read $fh, my $content, 1;
    my $val = unpack 'C', $content;
    return $val;
}

sub read_u16le {
    my $fh = shift @_;

    read $fh, my $content, 2;
    my $val = unpack 'v', $content;

    return $val;
}

sub read_u16be {
    my $fh = shift @_;

    read $fh, my $content, 2;
    my $val = unpack 'n', $content;

    return $val;
}

sub read_u32le {
    my $fh = shift @_;

    read $fh, my $content, 4;
    my $val = unpack 'V', $content;

    return $val;
}

sub read_u32be {
    my $fh = shift @_;

    read $fh, my $content, 4;
    my $val = unpack 'V', $content;

    return $val;
}

sub ddm_read {
    my $filename = shift @_;
    my %dbdesc;

    if ( !-f $filename ) {
        if ( -f $filename . '.ddm' ) {
            $filename = $filename . '.ddm';
        }
        else {
            croak "Can't find ddm file $filename";
        }
    }

    my $cfg = Config::IniFiles->new( -file => $filename );

    # FILE* sections
    my @sections = $cfg->Sections;
    print 'Sections ' . Dumper \@sections;
    my @s = grep /^FILE/, @sections;
    print 'FILE Sections ' . Dumper \@s;

    # Feed the {files} subhash with what is present in the ddm, mainly
    # fdt file names
    foreach my $s ( grep /^FILE/, @sections ) {
        foreach my $p ( $cfg->Parameters($s) ) {
            $dbdesc{files}->{$s}->{$p} = $cfg->val( $s, $p );
        }
    }

    # Implant bin and pnt files in %dbdesc for each fdt.
    foreach my $fnr ( keys %{ $dbdesc{files} } ) {
        if ( defined $fnr ) {
            my $basename = $dbdesc{files}->{$fnr}->{fdt};
            $basename =~ s/\.fdt$/.bin/;
            $dbdesc{files}->{$fnr}->{bin} = $basename
              if not defined $dbdesc{files}->{$fnr}->{bin};
            $basename =~ s/\.bin$/.pnt/;
            $dbdesc{files}->{$fnr}->{pnt} = $basename
              if not defined $dbdesc{files}->{$fnr}->{pnt};
        }
    }

    # DDF section
    my $count;
    foreach my $p ( $cfg->Parameters('DDF') ) {
        if ( $p eq 'cnt' ) {
            $count = $cfg->val( 'DDF', $p );
        }
        else {
            my $fieldesc = $cfg->val( 'DDF', $p );
            my ( $field, $type, $comment );
            if ( $fieldesc =~ m{ (\w{2}) \s* [,] (\w) \s* [;] \s* (\w*) }imxs )
            {
                ( $field, $type, $comment ) = ( $1, $2, $3 );
            }
            $dbdesc{fields}->{$p}->{name}    = $field;
            $dbdesc{fields}->{$p}->{type}    = $type;
            $dbdesc{fields}->{$p}->{comment} = $comment if defined $comment;
        }
    }
    print Dumper \%dbdesc;

    return \%dbdesc;
}

sub pnt_dump {
    my $dbdesc = shift @_;

    my @fn = map { $dbdesc->{files}->{$_}->{pnt} } keys %{ $dbdesc->{files} };

    foreach my $filename (@fn) {
        print "-- Reading pnt file $filename\n";
        my $fh = pnt_open($filename);

        print "-- Index\n";
        my $prevoffset=0;
        while ( !eof($fh) ) {
            my $i = read_u32le($fh);
            my $p = read_u32le($fh);
    
            my  $len = $p - $prevoffset;

            print "$i : $p ($len)\n";
            $prevoffset=$p;
        }

        close $fh or croak "Can't close $filename";
    }

}

sub ddm_dump {
    my $dbdesc = shift @_;

    print Dumper $dbdesc;
}

sub fdt_dump {
    my $dbdesc = shift @_;

    my @fn = map { $dbdesc->{files}->{$_}->{fdt} } keys %{ $dbdesc->{files} };

    foreach my $filename (@fn) {
        if ( !-f $filename ) {
            if ( -f $filename . '.fdt' ) {
                $filename = $filename . '.fdt';
            }
        }

        my $fh = fdt_open($filename);

        #
        # Header
        #

        # 8 octets
        #    print read_u8($fh), "\n";

        my $nf;
        print read_u16le($fh), "\n";
        print read_u16le($fh), "\n";
        print $nf = read_u16le($fh), "\n";
        print read_u16le($fh), "\n";

        # Nom de fichier de donnÃ©es
        print read_zstring($fh), "\n";

        # extension
        print read_zstring($fh), "\n";

        # Nom de fichier d'index
        print read_zstring($fh), "\n";

        # extension
        print read_zstring($fh), "\n";

        print "-- 5 champs 16bit\n";
        print read_u16le($fh), "\n";
        print read_u16le($fh), "\n";
        print read_u16le($fh), "\n";
        print read_u16le($fh), "\n";
        print read_u16le($fh), "\n";

        # premier champ
        print "-- Premier champ ??\n";
        my $fieldname = read_char($fh) . read_char($fh);
        print "$filename :",
          read_u16le($fh), " ",
          read_u16le($fh), " ",
          read_u16le($fh), " ",
          read_u16le($fh), " ",
          read_u16le($fh), "\n";

        my %field;

        # Description des champs
        print "-- Description des champs\n";
        for my $i ( 1 .. $nf ) {

            # nom du champ (zstring ?)
            my $fieldname = read_zstring($fh);
            print "$fieldname : ",
              read_u16le($fh), " ",
              read_u16le($fh), " ",
              read_u16le($fh), " ",
              read_u16le($fh), " ",
              read_u16le($fh), " ",
              "\n";
        }

        # informations sur les champs ou index ??
        print "-- Informations sur les champs ou index\n";
        for my $i ( 1 .. $nf ) {
            print read_u16le($fh),   " ",
              print read_u16le($fh), " ",
              print read_u16le($fh), " ",
              print read_u16le($fh), " ",
              "\n";
        }

        print read_u16le($fh), "\n";

        # Description des colonnes
        print "-- Description des colonnes\n";
        foreach my $i ( 1 .. $nf ) {
            print read_lstring($fh), "\n";
        }
    }

}

sub dump_bin {
    my $dbdesc = shift @_;
    my @fn = map { $dbdesc->{files}->{$_}->{bin} } keys %{ $dbdesc->{files} };

}

my $f = shift @ARGV;

# First, open .ddm file
my $dbdesc = ddm_read($f);

#ddm_dump($dbdesc);
fdt_dump($dbdesc);
pnt_dump($dbdesc);

