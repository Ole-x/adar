#!/usr/bin/perl
#
use strict;
use warnings;
use Carp;
use Config::IniFiles;
use Data::Dumper;
use Data::HexDump;
use Getopt::Std;
use Fcntl qw( :DEFAULT :seek );
use lib qw(/home/jfenal/dev/adar/bin);
use adar;

=pod

=head2 DB descriptor from DDM

    %dbdesc = {
        ddm => 'dummy.ddm',
        files => {
            'FILE1' => { fdt => 'dummy1.fdt', bin_file => 'dummy1.bin' },
            'FILE2' => { fdt => 'dummy2.fdt', bin_file => 'dummy2.bin' },
        },
        fields => {
            count => 123,
            1 => { name => AA, 'type' => 'S', comment => '...', },
            2 => { name => AB, 'type' => 'K', comment => '...', },
        },
    };

=cut

our $DEBUG = 0;
my ( $DUMP_DDM, $DUMP_FDT, $DUMP_PNT, $DUMP_BIN);

sub usage {
    print << "EOF";
$0 - Dump PET/ETKA files, supposed to be in an Adabas-ish file format.

Options :
  -h : help
  -D : dump DDM file
  -F : dump FDT file
  -P : dump PNT file
  -B : dump BIN file

EOF
}

=pod
sub bin_dump {
    my $dbdesc = shift @_;

    my @files = keys %{ $dbdesc->{files} };

    foreach my $file ( @files ) {
        my $filename = $dbdesc->{files}->{$file}->{bin_file};
        my $pnt = $dbdesc->{files}->{$file}->{pnt};
        my $fh = bin_open($filename);

        # Get field pointer from dbdesc
        my $field = $dbdesc->{ddm_fields};
        # Get field list
        my @fields = map { $field->{$_}->{name} } grep m{ \A \d+ \z}imxs, keys %{ $field };
        print "Fields :", Dumper \@fields;
        foreach my $f (@fields) {
            print "$f : type=$field->{$_}->{type}\n";
        }
        my $nr = 0;
        while( ! eof($fh) ) {
            if (defined $pnt->[$nr]) {
                my $len;
                if (defined $pnt->[$nr + 1]) {
                    $len = $pnt->[$nr + 1] - $pnt->[$nr] + 31;
                }
                else {
                    $len = 350;
                }
                print "Supposed length of reg : " . ( $pnt->[$nr + 1] - $pnt->[$nr]) . "\n";

                print '-' x 60 . "\n";
                seek $fh, $pnt->[$nr], SEEK_SET;
                my $buf;
                read $fh, $buf, $len;
                print HexDump $buf;

                seek $fh, $pnt->[$nr], SEEK_SET;
                print
                    read_u16le($fh),   " ",

                    read_u32le($fh),   " ",
                    read_u16le($fh),   " ",

                    read_u16le($fh),   " ",
                    read_u16le($fh),   " ",
                    read_zstring($fh),   " ",
                    "\n"; $len -= 12;

            }
            else {
                # print "record $nr seems to be deleted (not offset in pnt)\n";
                ;
            }

            $nr++;
        }
    }
}
=cut

my %opt;
getopts('dPFDBh', \%opt);

$DEBUG = 1 if defined $opt{d};
$DUMP_PNT = 1 if defined $opt{P};
$DUMP_FDT = 1 if defined $opt{F};
$DUMP_DDM = 1 if defined $opt{D};
$DUMP_BIN = 1 if defined $opt{B};

usage if defined $opt{h};

my $f = shift @ARGV;

# First, open .ddm file
my $dbdesc = ddm_read($f);

ddm_dump($dbdesc) if $DUMP_DDM;
fdt_load($dbdesc);
fdt_dump($dbdesc) if $DUMP_FDT;
print "Avant pnt_load\n";
pnt_load($dbdesc);
print "Apres pnt_load\n";
pnt_dump($dbdesc) if $DUMP_PNT;
#bin_dump($dbdesc) if $DUMP_BIN;

